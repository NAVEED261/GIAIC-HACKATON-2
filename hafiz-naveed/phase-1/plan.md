# Phase-1 Implementation Plan: Console-Based Todo System

**Created**: 2025-12-14
**Feature Branch**: `feature/phase-1-console-todo`
**Scope**: Python CLI application with in-memory task management

---

## Execution Strategy

This plan breaks down Phase-1 implementation into high-level architectural decisions and implementation steps. All code will be generated by Claude Code (AI) strictly following this plan and the specification.

---

## Part 1: Architecture & Design Decisions

### 1.1 System Architecture

**Decision**: Modular, agent-based architecture with supervisor and action agents.

- **HafizNaveed Agent (Main)**: Orchestrates CLI flow, menu display, and user input routing
- **TodoActionAgent (Sub)**: Handles core task operations (add, list, update, delete, mark_complete)
- **Task Model**: Lightweight in-memory data structure representing a task

**Rationale**: Separation of concerns allows CLI logic to be independent from task logic, making the system testable and extensible for future phases.

### 1.2 Data Model

**Decision**: Task entity stored as Python dictionary in in-memory list.

- **Task Structure**:
  ```
  {
    "id": <int>,
    "title": <str>,
    "status": <str> ("Pending" or "Completed")
  }
  ```
- **Storage**: Single in-memory list initialized on application start
- **ID Generation**: Auto-incrementing integer starting from 1

**Rationale**: Simplicity and clarity for Phase-1; easy to replace with database in Phase-2.

### 1.3 User Interaction Model

**Decision**: Menu-driven CLI loop with numerical option selection.

- **Flow**:
  1. Display main menu with options
  2. Get user input
  3. Route to appropriate agent action
  4. Display result
  5. Loop until "Exit" selected

**Rationale**: Menu-driven interface is intuitive, easy to implement, and provides clear user guidance.

### 1.4 Error Handling Strategy

**Decision**: Explicit validation with friendly error messages; no silent failures.

- **Invalid Menu Input**: Display "Invalid option. Please try again."
- **Invalid Task ID**: Display "Task not found. Please check the ID and try again."
- **Empty Title**: Display "Task title cannot be empty. Please try again."
- **Non-numeric ID**: Display "Please enter a valid task ID (number)."

**Rationale**: Users should never encounter crashes; clear feedback guides them to correct usage.

---

## Part 2: Implementation Steps

### Step 1: Create Project Structure

**Description**: Set up directory structure and initialization files.

**What needs to be done**:
- Create `src/` directory with:
  - `main.py` - Application entry point
  - `cli.py` - CLI handler and menu logic (HafizNaveed agent)
  - `task_manager.py` - Task storage and operations (TodoActionAgent logic)
  - `models.py` - Task data model
- Create `tests/` directory with:
  - `test_task_manager.py` - Task operations unit tests
  - `test_cli.py` - CLI integration tests
- Create `docs/` directory with:
  - `SETUP.md` - Installation and setup instructions
  - `USAGE.md` - User guide for running the application
- Create root files:
  - `requirements.txt` - Python dependencies (if any)
  - `README.md` - Project overview (already defined separately)

**Deliverable**: Directory structure ready for implementation.

---

### Step 2: Implement Task Model

**Description**: Define the Task data structure and validation.

**What needs to be done**:
- Create `models.py` with:
  - Task class or named tuple representing a task
  - Attributes: id (int), title (str), status (str: "Pending" or "Completed")
  - Validation: title must be non-empty string
  - Methods: to_dict() for display, update_title(), mark_complete()

**Deliverable**: Task model with validation ready for use by TaskManager.

---

### Step 3: Implement TodoActionAgent (Task Management Logic)

**Description**: Build core task operations as part of TodoActionAgent.

**What needs to be done**:
- Create `task_manager.py` with TodoActionAgent class:
  - **Data Store**: In-memory list to store Task objects
  - **Methods**:
    - `add_task(title: str) -> Task`: Add new task, auto-generate ID, return Task
    - `list_tasks() -> List[Task]`: Return all tasks in order
    - `get_task(task_id: int) -> Task or None`: Get task by ID
    - `update_task(task_id: int, new_title: str) -> bool`: Update task title, return success status
    - `delete_task(task_id: int) -> bool`: Delete task by ID, return success status
    - `mark_complete(task_id: int) -> bool`: Mark task as "Completed", return success status
  - **Error Handling**: Raise informative exceptions or return error indicators for invalid operations

**Deliverable**: TodoActionAgent with all five core operations fully implemented and tested internally.

---

### Step 4: Implement HafizNaveed Agent (CLI Handler)

**Description**: Build the main orchestrator agent that handles menu display and routing.

**What needs to be done**:
- Create `cli.py` with HafizNaveed class:
  - **Initialization**: Create TodoActionAgent instance
  - **Menu Display**: Display formatted menu with all options
  - **Input Handling**: Get user choice, validate input
  - **Routing Logic**: Route to TodoActionAgent based on user selection:
    - Option 1: Add Task → prompt for title → TodoActionAgent.add_task() → display result
    - Option 2: List Tasks → TodoActionAgent.list_tasks() → format and display
    - Option 3: Update Task → prompt for ID and new title → TodoActionAgent.update_task() → display result
    - Option 4: Delete Task → prompt for ID → TodoActionAgent.delete_task() → display result
    - Option 5: Mark Complete → prompt for ID → TodoActionAgent.mark_complete() → display result
    - Option 6: Exit → terminate application
  - **Error Display**: Catch exceptions and display friendly error messages
  - **Loop Control**: Main loop that continues until user selects Exit

**Deliverable**: HafizNaveed agent fully implements CLI flow with proper routing and error handling.

---

### Step 5: Implement Application Entry Point

**Description**: Create main.py that initializes and runs the application.

**What needs to be done**:
- Create `main.py`:
  - Import HafizNaveed from cli
  - Initialize HafizNaveed instance
  - Call run() or main() method to start the application loop
  - Handle application-level errors
- Define `if __name__ == "__main__":` block to run the app
- Include basic docstring explaining the application

**Deliverable**: Application can be started with `python main.py` and runs the complete CLI loop.

---

### Step 6: Implement Unit Tests

**Description**: Write tests for task operations to verify correctness.

**What needs to be done**:
- Create `tests/test_task_manager.py`:
  - Test add_task: verify task is added with correct ID, title, default status
  - Test list_tasks: verify all tasks are returned in order
  - Test update_task: verify title is updated, invalid ID returns error
  - Test delete_task: verify task is removed, invalid ID returns error
  - Test mark_complete: verify status changes to "Completed", invalid ID returns error
  - Test edge cases: empty title rejection, duplicate IDs prevention, task ID ordering

**Deliverable**: Unit tests pass with 100% success rate.

---

### Step 7: Implement Integration Tests

**Description**: Write tests that verify end-to-end CLI flows.

**What needs to be done**:
- Create `tests/test_cli.py`:
  - Test full add task flow: menu selection → input → task created → listed
  - Test update flow: create task → update title → verify change
  - Test complete flow: create task → mark complete → verify status change
  - Test delete flow: create task → delete → verify removal
  - Test error flows: invalid ID → error message displayed
  - Test exit flow: menu selection → application terminates

**Deliverable**: Integration tests pass with 100% success rate.

---

### Step 8: Create Documentation

**Description**: Write setup and usage guides.

**What needs to be done**:
- Create `docs/SETUP.md`:
  - Prerequisites (Python 3.8+)
  - Installation steps
  - Running the application
  - Troubleshooting common issues
- Create `docs/USAGE.md`:
  - Menu options explanation
  - Example workflows (add a task, complete a task, etc.)
  - Error messages and what they mean
  - Tips for using the CLI effectively

**Deliverable**: Clear, user-friendly documentation for installation and usage.

---

### Step 9: Verification & Testing

**Description**: Run all tests and verify the application works end-to-end.

**What needs to be done**:
- Run unit tests: `pytest tests/test_task_manager.py -v`
- Run integration tests: `pytest tests/test_cli.py -v`
- Manual end-to-end testing:
  - Start application: `python src/main.py`
  - Create multiple tasks
  - List tasks
  - Update task title
  - Mark task complete
  - Delete task
  - Exit application
- Verify all success criteria from specification are met
- Verify error handling works for all edge cases

**Deliverable**: All tests pass; application fully functional and meets specification.

---

## Part 3: Acceptance Criteria

### All Requirements Met

- ✅ FR-001: Menu-driven CLI with all options
- ✅ FR-002: Add task with unique ID and title
- ✅ FR-003: Display tasks with ID, title, status
- ✅ FR-004: Update task title by ID
- ✅ FR-005: Mark task complete by ID
- ✅ FR-006: Delete task by ID
- ✅ FR-007: Input validation and friendly errors
- ✅ FR-008: In-memory state management
- ✅ FR-009: Loop until Exit selected
- ✅ FR-010: Status defaults to "Pending"

### Success Criteria Met

- ✅ SC-001: Tasks added in under 30 seconds
- ✅ SC-002: Clear output format for task listing
- ✅ SC-003: 100% input validation, no crashes
- ✅ SC-004: Friendly error messages for invalid IDs
- ✅ SC-005: All five operations independently functional
- ✅ SC-006: Clean application exit

### Architecture Decisions Documented

- ✅ HafizNaveed (main agent) defined and implemented
- ✅ TodoActionAgent (sub agent) defined and implemented
- ✅ Agent responsibilities and routing logic clear
- ✅ No features beyond Phase-1 scope included

---

## Part 4: Readiness Checklist

**Before implementation begins**:

- ✅ Specification clearly defines all requirements
- ✅ Architecture decisions are explicit and justified
- ✅ Implementation steps are sequential and achievable
- ✅ Success criteria are measurable
- ✅ Error handling strategy is defined
- ✅ Testing strategy is clear (unit + integration)

**After implementation completes**:

- Run all tests and verify passage
- Verify specification alignment
- Review code for clarity and maintainability
- Ensure documentation is complete and accurate

---

**Status**: Ready for Task Generation
**Next Phase**: `/sp.tasks` to generate detailed task breakdown
